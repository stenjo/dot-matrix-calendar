/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockspi_master.h"

static const char* CMockString_cycles_remain_o = "cycles_remain_o";
static const char* CMockString_dev = "dev";
static const char* CMockString_dev_config = "dev_config";
static const char* CMockString_device = "device";
static const char* CMockString_dummy_o = "dummy_o";
static const char* CMockString_duty_cycle = "duty_cycle";
static const char* CMockString_eff_clk = "eff_clk";
static const char* CMockString_fapb = "fapb";
static const char* CMockString_gpio_is_used = "gpio_is_used";
static const char* CMockString_handle = "handle";
static const char* CMockString_host_id = "host_id";
static const char* CMockString_hz = "hz";
static const char* CMockString_input_delay_ns = "input_delay_ns";
static const char* CMockString_spi_bus_add_device = "spi_bus_add_device";
static const char* CMockString_spi_bus_remove_device = "spi_bus_remove_device";
static const char* CMockString_spi_device_acquire_bus = "spi_device_acquire_bus";
static const char* CMockString_spi_device_get_trans_result = "spi_device_get_trans_result";
static const char* CMockString_spi_device_polling_end = "spi_device_polling_end";
static const char* CMockString_spi_device_polling_start = "spi_device_polling_start";
static const char* CMockString_spi_device_polling_transmit = "spi_device_polling_transmit";
static const char* CMockString_spi_device_queue_trans = "spi_device_queue_trans";
static const char* CMockString_spi_device_release_bus = "spi_device_release_bus";
static const char* CMockString_spi_device_transmit = "spi_device_transmit";
static const char* CMockString_spi_get_actual_clock = "spi_get_actual_clock";
static const char* CMockString_spi_get_freq_limit = "spi_get_freq_limit";
static const char* CMockString_spi_get_timing = "spi_get_timing";
static const char* CMockString_ticks_to_wait = "ticks_to_wait";
static const char* CMockString_trans_desc = "trans_desc";
static const char* CMockString_wait = "wait";

typedef struct _CMOCK_spi_bus_add_device_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_host_device_t Expected_host_id;
  const spi_device_interface_config_t* Expected_dev_config;
  spi_device_handle_t* Expected_handle;

} CMOCK_spi_bus_add_device_CALL_INSTANCE;

typedef struct _CMOCK_spi_bus_remove_device_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;

} CMOCK_spi_bus_remove_device_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_queue_trans_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;
  TickType_t Expected_ticks_to_wait;

} CMOCK_spi_device_queue_trans_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_get_trans_result_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t** Expected_trans_desc;
  TickType_t Expected_ticks_to_wait;

} CMOCK_spi_device_get_trans_result_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_transmit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;

} CMOCK_spi_device_transmit_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_polling_start_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;
  TickType_t Expected_ticks_to_wait;

} CMOCK_spi_device_polling_start_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_polling_end_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  TickType_t Expected_ticks_to_wait;

} CMOCK_spi_device_polling_end_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_polling_transmit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;

} CMOCK_spi_device_polling_transmit_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_acquire_bus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_device;
  TickType_t Expected_wait;

} CMOCK_spi_device_acquire_bus_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_release_bus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  spi_device_handle_t Expected_dev;

} CMOCK_spi_device_release_bus_CALL_INSTANCE;

typedef struct _CMOCK_spi_get_actual_clock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  int Expected_fapb;
  int Expected_hz;
  int Expected_duty_cycle;

} CMOCK_spi_get_actual_clock_CALL_INSTANCE;

typedef struct _CMOCK_spi_get_timing_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool Expected_gpio_is_used;
  int Expected_input_delay_ns;
  int Expected_eff_clk;
  int* Expected_dummy_o;
  int* Expected_cycles_remain_o;

} CMOCK_spi_get_timing_CALL_INSTANCE;

typedef struct _CMOCK_spi_get_freq_limit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  bool Expected_gpio_is_used;
  int Expected_input_delay_ns;

} CMOCK_spi_get_freq_limit_CALL_INSTANCE;

static struct Mockspi_masterInstance
{
  CMOCK_MEM_INDEX_TYPE spi_bus_add_device_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_bus_remove_device_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_queue_trans_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_get_trans_result_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_transmit_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_polling_start_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_polling_end_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_polling_transmit_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_acquire_bus_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_device_release_bus_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_get_actual_clock_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_get_timing_CallInstance;
  CMOCK_MEM_INDEX_TYPE spi_get_freq_limit_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockspi_master_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.spi_bus_add_device_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_bus_add_device);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_bus_remove_device_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_bus_remove_device);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_queue_trans_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_queue_trans);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_get_trans_result_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_get_trans_result);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_transmit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_transmit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_polling_start_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_polling_start);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_polling_end_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_polling_end);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_polling_transmit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_polling_transmit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_acquire_bus_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_acquire_bus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_device_release_bus_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_release_bus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_get_actual_clock_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_get_actual_clock);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_get_timing_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_get_timing);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spi_get_freq_limit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_get_freq_limit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockspi_master_Init(void)
{
  Mockspi_master_Destroy();
}

void Mockspi_master_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

esp_err_t spi_bus_add_device(spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_bus_add_device);
  cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_bus_add_device_CallInstance);
  Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemNext(Mock.spi_bus_add_device_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_add_device,CMockString_host_id);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_host_id), (void*)(&host_id), sizeof(spi_host_device_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_add_device,CMockString_dev_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_dev_config), (void*)(dev_config), sizeof(const spi_device_interface_config_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_add_device,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_handle), (void*)(handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_bus_add_device(CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance, spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle);
void CMockExpectParameters_spi_bus_add_device(CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance, spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle)
{
  memcpy((void*)(&cmock_call_instance->Expected_host_id), (void*)(&host_id),
         sizeof(spi_host_device_t[sizeof(host_id) == sizeof(spi_host_device_t) ? 1 : -1])); /* add spi_host_device_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_dev_config = dev_config;
  cmock_call_instance->Expected_handle = handle;
}

void spi_bus_add_device_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_add_device_CALL_INSTANCE));
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_add_device_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_bus_add_device(cmock_call_instance, host_id, dev_config, handle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_bus_remove_device(spi_device_handle_t handle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_bus_remove_device);
  cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_bus_remove_device_CallInstance);
  Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemNext(Mock.spi_bus_remove_device_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_remove_device,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_bus_remove_device(CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle);
void CMockExpectParameters_spi_bus_remove_device(CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
}

void spi_bus_remove_device_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_remove_device_CALL_INSTANCE));
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_remove_device_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_bus_remove_device(cmock_call_instance, handle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_device_queue_trans(spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_queue_trans);
  cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_queue_trans_CallInstance);
  Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemNext(Mock.spi_device_queue_trans_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_queue_trans,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_queue_trans,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_queue_trans,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_queue_trans(CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_queue_trans(CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_trans_desc = trans_desc;
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void spi_device_queue_trans_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_queue_trans_CALL_INSTANCE));
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemChain(Mock.spi_device_queue_trans_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_queue_trans(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_device_get_trans_result(spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_get_trans_result);
  cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_get_trans_result_CallInstance);
  Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemNext(Mock.spi_device_get_trans_result_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_get_trans_result,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_get_trans_result,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_trans_desc, trans_desc, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_get_trans_result,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_get_trans_result(CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_get_trans_result(CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_trans_desc = trans_desc;
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void spi_device_get_trans_result_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_get_trans_result_CALL_INSTANCE));
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemChain(Mock.spi_device_get_trans_result_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_get_trans_result(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_device_transmit(spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_transmit);
  cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_transmit_CallInstance);
  Mock.spi_device_transmit_CallInstance = CMock_Guts_MemNext(Mock.spi_device_transmit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_transmit,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_transmit,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_transmit(CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc);
void CMockExpectParameters_spi_device_transmit(CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_trans_desc = trans_desc;
}

void spi_device_transmit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_transmit_CALL_INSTANCE));
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_transmit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_transmit(cmock_call_instance, handle, trans_desc);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_device_polling_start(spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_polling_start);
  cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_polling_start_CallInstance);
  Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_start_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_start,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_start,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_start,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_polling_start(CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_polling_start(CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_trans_desc = trans_desc;
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void spi_device_polling_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_start_CALL_INSTANCE));
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_start_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_polling_start(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_device_polling_end(spi_device_handle_t handle, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_polling_end);
  cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_polling_end_CallInstance);
  Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_end_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_end,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_end,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_polling_end(CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_polling_end(CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void spi_device_polling_end_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_end_CALL_INSTANCE));
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_end_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_polling_end(cmock_call_instance, handle, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_device_polling_transmit(spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_polling_transmit);
  cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_polling_transmit_CallInstance);
  Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_transmit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_transmit,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_transmit,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_polling_transmit(CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc);
void CMockExpectParameters_spi_device_polling_transmit(CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_trans_desc = trans_desc;
}

void spi_device_polling_transmit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_transmit_CALL_INSTANCE));
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_transmit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_polling_transmit(cmock_call_instance, handle, trans_desc);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t spi_device_acquire_bus(spi_device_handle_t device, TickType_t wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_acquire_bus);
  cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_acquire_bus_CallInstance);
  Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemNext(Mock.spi_device_acquire_bus_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_acquire_bus,CMockString_device);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_device), (void*)(&device), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_device_acquire_bus,CMockString_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wait), (void*)(&wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_acquire_bus(CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t device, TickType_t wait);
void CMockExpectParameters_spi_device_acquire_bus(CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t device, TickType_t wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_device), (void*)(&device),
         sizeof(spi_device_handle_t[sizeof(device) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_wait), (void*)(&wait),
         sizeof(TickType_t[sizeof(wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void spi_device_acquire_bus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t device, TickType_t wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_acquire_bus_CALL_INSTANCE));
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_acquire_bus_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_acquire_bus(cmock_call_instance, device, wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_release_bus(spi_device_handle_t dev)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_release_bus);
  cmock_call_instance = (CMOCK_spi_device_release_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_release_bus_CallInstance);
  Mock.spi_device_release_bus_CallInstance = CMock_Guts_MemNext(Mock.spi_device_release_bus_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_device_release_bus,CMockString_dev);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dev), (void*)(&dev), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_spi_device_release_bus(CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t dev);
void CMockExpectParameters_spi_device_release_bus(CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t dev)
{
  memcpy((void*)(&cmock_call_instance->Expected_dev), (void*)(&dev),
         sizeof(spi_device_handle_t[sizeof(dev) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
}

void spi_device_release_bus_CMockExpect(UNITY_LINE_TYPE cmock_line, spi_device_handle_t dev)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_release_bus_CALL_INSTANCE));
  CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_release_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_release_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_release_bus_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_device_release_bus(cmock_call_instance, dev);
}

int spi_get_actual_clock(int fapb, int hz, int duty_cycle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_get_actual_clock);
  cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_get_actual_clock_CallInstance);
  Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemNext(Mock.spi_get_actual_clock_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_get_actual_clock,CMockString_fapb);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_fapb, fapb, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_get_actual_clock,CMockString_hz);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hz, hz, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_get_actual_clock,CMockString_duty_cycle);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_duty_cycle, duty_cycle, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_get_actual_clock(CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance, int fapb, int hz, int duty_cycle);
void CMockExpectParameters_spi_get_actual_clock(CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance, int fapb, int hz, int duty_cycle)
{
  cmock_call_instance->Expected_fapb = fapb;
  cmock_call_instance->Expected_hz = hz;
  cmock_call_instance->Expected_duty_cycle = duty_cycle;
}

void spi_get_actual_clock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int fapb, int hz, int duty_cycle, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_actual_clock_CALL_INSTANCE));
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemChain(Mock.spi_get_actual_clock_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_get_actual_clock(cmock_call_instance, fapb, hz, duty_cycle);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void spi_get_timing(bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_get_timing);
  cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_get_timing_CallInstance);
  Mock.spi_get_timing_CallInstance = CMock_Guts_MemNext(Mock.spi_get_timing_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_gpio_is_used);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_gpio_is_used, gpio_is_used, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_input_delay_ns);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_input_delay_ns, input_delay_ns, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_eff_clk);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_eff_clk, eff_clk, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_dummy_o);
    if (cmock_call_instance->Expected_dummy_o == NULL)
      { UNITY_TEST_ASSERT_NULL(dummy_o, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_dummy_o, dummy_o, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_cycles_remain_o);
    if (cmock_call_instance->Expected_cycles_remain_o == NULL)
      { UNITY_TEST_ASSERT_NULL(cycles_remain_o, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_cycles_remain_o, cycles_remain_o, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_spi_get_timing(CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o);
void CMockExpectParameters_spi_get_timing(CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o)
{
  cmock_call_instance->Expected_gpio_is_used = gpio_is_used;
  cmock_call_instance->Expected_input_delay_ns = input_delay_ns;
  cmock_call_instance->Expected_eff_clk = eff_clk;
  cmock_call_instance->Expected_dummy_o = dummy_o;
  cmock_call_instance->Expected_cycles_remain_o = cycles_remain_o;
}

void spi_get_timing_CMockExpect(UNITY_LINE_TYPE cmock_line, bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_timing_CALL_INSTANCE));
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_timing_CallInstance = CMock_Guts_MemChain(Mock.spi_get_timing_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_get_timing(cmock_call_instance, gpio_is_used, input_delay_ns, eff_clk, dummy_o, cycles_remain_o);
}

int spi_get_freq_limit(bool gpio_is_used, int input_delay_ns)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_get_freq_limit);
  cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_get_freq_limit_CallInstance);
  Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemNext(Mock.spi_get_freq_limit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spi_get_freq_limit,CMockString_gpio_is_used);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_gpio_is_used, gpio_is_used, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spi_get_freq_limit,CMockString_input_delay_ns);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_input_delay_ns, input_delay_ns, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_get_freq_limit(CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns);
void CMockExpectParameters_spi_get_freq_limit(CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns)
{
  cmock_call_instance->Expected_gpio_is_used = gpio_is_used;
  cmock_call_instance->Expected_input_delay_ns = input_delay_ns;
}

void spi_get_freq_limit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, bool gpio_is_used, int input_delay_ns, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_freq_limit_CALL_INSTANCE));
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemChain(Mock.spi_get_freq_limit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spi_get_freq_limit(cmock_call_instance, gpio_is_used, input_delay_ns);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

