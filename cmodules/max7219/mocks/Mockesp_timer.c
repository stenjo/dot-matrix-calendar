/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockesp_timer.h"

static const char* CMockString_create_args = "create_args";
static const char* CMockString_esp_timer_create = "esp_timer_create";
static const char* CMockString_esp_timer_deinit = "esp_timer_deinit";
static const char* CMockString_esp_timer_delete = "esp_timer_delete";
static const char* CMockString_esp_timer_dump = "esp_timer_dump";
static const char* CMockString_esp_timer_early_init = "esp_timer_early_init";
static const char* CMockString_esp_timer_get_expiry_time = "esp_timer_get_expiry_time";
static const char* CMockString_esp_timer_get_next_alarm = "esp_timer_get_next_alarm";
static const char* CMockString_esp_timer_get_next_alarm_for_wake_up = "esp_timer_get_next_alarm_for_wake_up";
static const char* CMockString_esp_timer_get_period = "esp_timer_get_period";
static const char* CMockString_esp_timer_get_time = "esp_timer_get_time";
static const char* CMockString_esp_timer_init = "esp_timer_init";
static const char* CMockString_esp_timer_is_active = "esp_timer_is_active";
static const char* CMockString_esp_timer_isr_dispatch_need_yield = "esp_timer_isr_dispatch_need_yield";
static const char* CMockString_esp_timer_restart = "esp_timer_restart";
static const char* CMockString_esp_timer_start_once = "esp_timer_start_once";
static const char* CMockString_esp_timer_start_periodic = "esp_timer_start_periodic";
static const char* CMockString_esp_timer_stop = "esp_timer_stop";
static const char* CMockString_expiry = "expiry";
static const char* CMockString_out_handle = "out_handle";
static const char* CMockString_period = "period";
static const char* CMockString_stream = "stream";
static const char* CMockString_timeout_us = "timeout_us";
static const char* CMockString_timer = "timer";

typedef struct _CMOCK_esp_timer_early_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_esp_timer_early_init_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_esp_timer_init_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_deinit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_esp_timer_deinit_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_create_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  const esp_timer_create_args_t* Expected_create_args;
  esp_timer_handle_t* Expected_out_handle;

} CMOCK_esp_timer_create_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_start_once_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  esp_timer_handle_t Expected_timer;
  uint64_t Expected_timeout_us;

} CMOCK_esp_timer_start_once_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_start_periodic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  esp_timer_handle_t Expected_timer;
  uint64_t Expected_period;

} CMOCK_esp_timer_start_periodic_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_restart_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  esp_timer_handle_t Expected_timer;
  uint64_t Expected_timeout_us;

} CMOCK_esp_timer_restart_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_stop_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  esp_timer_handle_t Expected_timer;

} CMOCK_esp_timer_stop_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_delete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  esp_timer_handle_t Expected_timer;

} CMOCK_esp_timer_delete_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_get_time_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int64_t ReturnVal;

} CMOCK_esp_timer_get_time_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_get_next_alarm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int64_t ReturnVal;

} CMOCK_esp_timer_get_next_alarm_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_get_next_alarm_for_wake_up_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int64_t ReturnVal;

} CMOCK_esp_timer_get_next_alarm_for_wake_up_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_get_period_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  esp_timer_handle_t Expected_timer;
  uint64_t* Expected_period;

} CMOCK_esp_timer_get_period_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  esp_timer_handle_t Expected_timer;
  uint64_t* Expected_expiry;

} CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_dump_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  FILE* Expected_stream;

} CMOCK_esp_timer_dump_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_isr_dispatch_need_yield_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_esp_timer_isr_dispatch_need_yield_CALL_INSTANCE;

typedef struct _CMOCK_esp_timer_is_active_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool ReturnVal;
  esp_timer_handle_t Expected_timer;

} CMOCK_esp_timer_is_active_CALL_INSTANCE;

static struct Mockesp_timerInstance
{
  CMOCK_MEM_INDEX_TYPE esp_timer_early_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_deinit_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_create_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_start_once_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_start_periodic_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_restart_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_stop_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_delete_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_get_time_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_get_next_alarm_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_get_next_alarm_for_wake_up_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_get_period_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_get_expiry_time_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_dump_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_isr_dispatch_need_yield_CallInstance;
  CMOCK_MEM_INDEX_TYPE esp_timer_is_active_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockesp_timer_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.esp_timer_early_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_early_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_deinit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_deinit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_create_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_create);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_start_once_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_start_once);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_start_periodic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_start_periodic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_restart_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_restart);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_stop_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_stop);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_delete_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_delete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_get_time_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_get_time);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_get_next_alarm_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_get_next_alarm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_get_next_alarm_for_wake_up_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_get_next_alarm_for_wake_up);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_get_period_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_get_period);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_get_expiry_time_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_get_expiry_time);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_dump_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_dump);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_isr_dispatch_need_yield_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_isr_dispatch_need_yield);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.esp_timer_is_active_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_esp_timer_is_active);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockesp_timer_Init(void)
{
  Mockesp_timer_Destroy();
}

void Mockesp_timer_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

esp_err_t esp_timer_early_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_early_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_early_init);
  cmock_call_instance = (CMOCK_esp_timer_early_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_early_init_CallInstance);
  Mock.esp_timer_early_init_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_early_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void esp_timer_early_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_early_init_CALL_INSTANCE));
  CMOCK_esp_timer_early_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_early_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_early_init_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_early_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_init);
  cmock_call_instance = (CMOCK_esp_timer_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_init_CallInstance);
  Mock.esp_timer_init_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void esp_timer_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_init_CALL_INSTANCE));
  CMOCK_esp_timer_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_init_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_deinit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_deinit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_deinit);
  cmock_call_instance = (CMOCK_esp_timer_deinit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_deinit_CallInstance);
  Mock.esp_timer_deinit_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_deinit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void esp_timer_deinit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_deinit_CALL_INSTANCE));
  CMOCK_esp_timer_deinit_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_deinit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_deinit_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_deinit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_create(const esp_timer_create_args_t* create_args, esp_timer_handle_t* out_handle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_create_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_create);
  cmock_call_instance = (CMOCK_esp_timer_create_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_create_CallInstance);
  Mock.esp_timer_create_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_create_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_create,CMockString_create_args);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_create_args), (void*)(create_args), sizeof(const esp_timer_create_args_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_create,CMockString_out_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_out_handle), (void*)(out_handle), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_create(CMOCK_esp_timer_create_CALL_INSTANCE* cmock_call_instance, const esp_timer_create_args_t* create_args, esp_timer_handle_t* out_handle);
void CMockExpectParameters_esp_timer_create(CMOCK_esp_timer_create_CALL_INSTANCE* cmock_call_instance, const esp_timer_create_args_t* create_args, esp_timer_handle_t* out_handle)
{
  cmock_call_instance->Expected_create_args = create_args;
  cmock_call_instance->Expected_out_handle = out_handle;
}

void esp_timer_create_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const esp_timer_create_args_t* create_args, esp_timer_handle_t* out_handle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_create_CALL_INSTANCE));
  CMOCK_esp_timer_create_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_create_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_create_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_create_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_create(cmock_call_instance, create_args, out_handle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_start_once(esp_timer_handle_t timer, uint64_t timeout_us)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_start_once_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_start_once);
  cmock_call_instance = (CMOCK_esp_timer_start_once_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_start_once_CallInstance);
  Mock.esp_timer_start_once_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_start_once_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_start_once,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_start_once,CMockString_timeout_us);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timeout_us), (void*)(&timeout_us), sizeof(uint64_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_start_once(CMOCK_esp_timer_start_once_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t timeout_us);
void CMockExpectParameters_esp_timer_start_once(CMOCK_esp_timer_start_once_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t timeout_us)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_timeout_us), (void*)(&timeout_us),
         sizeof(uint64_t[sizeof(timeout_us) == sizeof(uint64_t) ? 1 : -1])); /* add uint64_t to :treat_as_array if this causes an error */
}

void esp_timer_start_once_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, uint64_t timeout_us, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_start_once_CALL_INSTANCE));
  CMOCK_esp_timer_start_once_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_start_once_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_start_once_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_start_once_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_start_once(cmock_call_instance, timer, timeout_us);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_start_periodic(esp_timer_handle_t timer, uint64_t period)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_start_periodic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_start_periodic);
  cmock_call_instance = (CMOCK_esp_timer_start_periodic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_start_periodic_CallInstance);
  Mock.esp_timer_start_periodic_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_start_periodic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_start_periodic,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_start_periodic,CMockString_period);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_period), (void*)(&period), sizeof(uint64_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_start_periodic(CMOCK_esp_timer_start_periodic_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t period);
void CMockExpectParameters_esp_timer_start_periodic(CMOCK_esp_timer_start_periodic_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t period)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_period), (void*)(&period),
         sizeof(uint64_t[sizeof(period) == sizeof(uint64_t) ? 1 : -1])); /* add uint64_t to :treat_as_array if this causes an error */
}

void esp_timer_start_periodic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, uint64_t period, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_start_periodic_CALL_INSTANCE));
  CMOCK_esp_timer_start_periodic_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_start_periodic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_start_periodic_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_start_periodic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_start_periodic(cmock_call_instance, timer, period);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_restart(esp_timer_handle_t timer, uint64_t timeout_us)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_restart_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_restart);
  cmock_call_instance = (CMOCK_esp_timer_restart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_restart_CallInstance);
  Mock.esp_timer_restart_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_restart_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_restart,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_restart,CMockString_timeout_us);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timeout_us), (void*)(&timeout_us), sizeof(uint64_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_restart(CMOCK_esp_timer_restart_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t timeout_us);
void CMockExpectParameters_esp_timer_restart(CMOCK_esp_timer_restart_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t timeout_us)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_timeout_us), (void*)(&timeout_us),
         sizeof(uint64_t[sizeof(timeout_us) == sizeof(uint64_t) ? 1 : -1])); /* add uint64_t to :treat_as_array if this causes an error */
}

void esp_timer_restart_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, uint64_t timeout_us, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_restart_CALL_INSTANCE));
  CMOCK_esp_timer_restart_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_restart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_restart_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_restart_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_restart(cmock_call_instance, timer, timeout_us);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_stop(esp_timer_handle_t timer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_stop_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_stop);
  cmock_call_instance = (CMOCK_esp_timer_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_stop_CallInstance);
  Mock.esp_timer_stop_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_stop_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_stop,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_stop(CMOCK_esp_timer_stop_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer);
void CMockExpectParameters_esp_timer_stop(CMOCK_esp_timer_stop_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
}

void esp_timer_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_stop_CALL_INSTANCE));
  CMOCK_esp_timer_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_stop_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_stop_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_stop(cmock_call_instance, timer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_delete(esp_timer_handle_t timer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_delete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_delete);
  cmock_call_instance = (CMOCK_esp_timer_delete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_delete_CallInstance);
  Mock.esp_timer_delete_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_delete_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_delete,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_delete(CMOCK_esp_timer_delete_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer);
void CMockExpectParameters_esp_timer_delete(CMOCK_esp_timer_delete_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
}

void esp_timer_delete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_delete_CALL_INSTANCE));
  CMOCK_esp_timer_delete_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_delete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_delete_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_delete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_delete(cmock_call_instance, timer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

int64_t esp_timer_get_time(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_get_time_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_get_time);
  cmock_call_instance = (CMOCK_esp_timer_get_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_get_time_CallInstance);
  Mock.esp_timer_get_time_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_get_time_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void esp_timer_get_time_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int64_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_get_time_CALL_INSTANCE));
  CMOCK_esp_timer_get_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_get_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_get_time_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_get_time_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(int64_t[sizeof(cmock_to_return) == sizeof(int64_t) ? 1 : -1])); /* add int64_t to :treat_as_array if this causes an error */
}

int64_t esp_timer_get_next_alarm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_get_next_alarm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_get_next_alarm);
  cmock_call_instance = (CMOCK_esp_timer_get_next_alarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_get_next_alarm_CallInstance);
  Mock.esp_timer_get_next_alarm_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_get_next_alarm_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void esp_timer_get_next_alarm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int64_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_get_next_alarm_CALL_INSTANCE));
  CMOCK_esp_timer_get_next_alarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_get_next_alarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_get_next_alarm_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_get_next_alarm_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(int64_t[sizeof(cmock_to_return) == sizeof(int64_t) ? 1 : -1])); /* add int64_t to :treat_as_array if this causes an error */
}

int64_t esp_timer_get_next_alarm_for_wake_up(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_get_next_alarm_for_wake_up_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_get_next_alarm_for_wake_up);
  cmock_call_instance = (CMOCK_esp_timer_get_next_alarm_for_wake_up_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_get_next_alarm_for_wake_up_CallInstance);
  Mock.esp_timer_get_next_alarm_for_wake_up_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_get_next_alarm_for_wake_up_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void esp_timer_get_next_alarm_for_wake_up_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int64_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_get_next_alarm_for_wake_up_CALL_INSTANCE));
  CMOCK_esp_timer_get_next_alarm_for_wake_up_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_get_next_alarm_for_wake_up_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_get_next_alarm_for_wake_up_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_get_next_alarm_for_wake_up_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(int64_t[sizeof(cmock_to_return) == sizeof(int64_t) ? 1 : -1])); /* add int64_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_get_period(esp_timer_handle_t timer, uint64_t* period)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_get_period_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_get_period);
  cmock_call_instance = (CMOCK_esp_timer_get_period_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_get_period_CallInstance);
  Mock.esp_timer_get_period_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_get_period_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_get_period,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_get_period,CMockString_period);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_period), (void*)(period), sizeof(uint64_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_get_period(CMOCK_esp_timer_get_period_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t* period);
void CMockExpectParameters_esp_timer_get_period(CMOCK_esp_timer_get_period_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t* period)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_period = period;
}

void esp_timer_get_period_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, uint64_t* period, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_get_period_CALL_INSTANCE));
  CMOCK_esp_timer_get_period_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_get_period_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_get_period_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_get_period_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_get_period(cmock_call_instance, timer, period);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_get_expiry_time(esp_timer_handle_t timer, uint64_t* expiry)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_get_expiry_time);
  cmock_call_instance = (CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_get_expiry_time_CallInstance);
  Mock.esp_timer_get_expiry_time_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_get_expiry_time_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_get_expiry_time,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_get_expiry_time,CMockString_expiry);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_expiry), (void*)(expiry), sizeof(uint64_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_get_expiry_time(CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t* expiry);
void CMockExpectParameters_esp_timer_get_expiry_time(CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer, uint64_t* expiry)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_expiry = expiry;
}

void esp_timer_get_expiry_time_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, uint64_t* expiry, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE));
  CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_get_expiry_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_get_expiry_time_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_get_expiry_time_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_get_expiry_time(cmock_call_instance, timer, expiry);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t esp_timer_dump(FILE* stream)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_dump_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_dump);
  cmock_call_instance = (CMOCK_esp_timer_dump_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_dump_CallInstance);
  Mock.esp_timer_dump_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_dump_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_dump,CMockString_stream);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_stream), (void*)(stream), sizeof(FILE), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_dump(CMOCK_esp_timer_dump_CALL_INSTANCE* cmock_call_instance, FILE* stream);
void CMockExpectParameters_esp_timer_dump(CMOCK_esp_timer_dump_CALL_INSTANCE* cmock_call_instance, FILE* stream)
{
  cmock_call_instance->Expected_stream = stream;
}

void esp_timer_dump_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, FILE* stream, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_dump_CALL_INSTANCE));
  CMOCK_esp_timer_dump_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_dump_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_dump_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_dump_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_dump(cmock_call_instance, stream);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void esp_timer_isr_dispatch_need_yield(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_isr_dispatch_need_yield_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_isr_dispatch_need_yield);
  cmock_call_instance = (CMOCK_esp_timer_isr_dispatch_need_yield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_isr_dispatch_need_yield_CallInstance);
  Mock.esp_timer_isr_dispatch_need_yield_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_isr_dispatch_need_yield_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void esp_timer_isr_dispatch_need_yield_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_isr_dispatch_need_yield_CALL_INSTANCE));
  CMOCK_esp_timer_isr_dispatch_need_yield_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_isr_dispatch_need_yield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_isr_dispatch_need_yield_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_isr_dispatch_need_yield_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

bool esp_timer_is_active(esp_timer_handle_t timer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_esp_timer_is_active_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_esp_timer_is_active);
  cmock_call_instance = (CMOCK_esp_timer_is_active_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.esp_timer_is_active_CallInstance);
  Mock.esp_timer_is_active_CallInstance = CMock_Guts_MemNext(Mock.esp_timer_is_active_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_esp_timer_is_active,CMockString_timer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer), sizeof(esp_timer_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_esp_timer_is_active(CMOCK_esp_timer_is_active_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer);
void CMockExpectParameters_esp_timer_is_active(CMOCK_esp_timer_is_active_CALL_INSTANCE* cmock_call_instance, esp_timer_handle_t timer)
{
  memcpy((void*)(&cmock_call_instance->Expected_timer), (void*)(&timer),
         sizeof(esp_timer_handle_t[sizeof(timer) == sizeof(esp_timer_handle_t) ? 1 : -1])); /* add esp_timer_handle_t to :treat_as_array if this causes an error */
}

void esp_timer_is_active_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_timer_handle_t timer, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_esp_timer_is_active_CALL_INSTANCE));
  CMOCK_esp_timer_is_active_CALL_INSTANCE* cmock_call_instance = (CMOCK_esp_timer_is_active_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.esp_timer_is_active_CallInstance = CMock_Guts_MemChain(Mock.esp_timer_is_active_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_esp_timer_is_active(cmock_call_instance, timer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

